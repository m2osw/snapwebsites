// Snap Websites Server -- snap manager CGI, daemon, library, plugins
// Copyright (c) 2016-2019  Made to Order Software Corp.  All Rights Reserved
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#pragma once

// self
//
#include    "snapmanager/server_status.h"
#include    "snapmanager/bundle.h"
#include    "snapmanager/version.h"        // Auto-generated by cmake


// snapwebsites
//
#include    <snapwebsites/snapwebsites.h>


// serverplugins
//
#include    <serverplugins/signals.h>


// advgetopt
//
#include    <advgetopt/conf_file.h>


// eventdispatcher
//
#include    <eventdispatcher/signal_handler.h>


// C
//
#include    <sys/stat.h>


// C++
//
#include    <set>


namespace snap_manager
{


enum class name_t
{
    SNAP_NAME_MANAGER_STATUS_FILE_HEADER
};
char const * get_name(name_t name) __attribute__ ((const));


DECLARE_MAIN_EXCEPTION(snapmanager_exception);

DECLARE_EXCEPTION(snapmanager_exception, snapmanager_exception_cannot_load_plugins);
DECLARE_EXCEPTION(snapmanager_exception, snapmanager_exception_invalid_parameters);
DECLARE_EXCEPTION(snapmanager_exception, snapmanager_exception_undefined);



enum class service_status_t
{
    SERVICE_STATUS_UNKNOWN = -2,
    SERVICE_STATUS_NOT_INSTALLED = -1,
    SERVICE_STATUS_DISABLED,
    SERVICE_STATUS_ENABLED,
    SERVICE_STATUS_ACTIVE,
    SERVICE_STATUS_FAILED
};


typedef uint32_t   replace_configuration_value_t;

replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_NO_FLAGS        =  0x0000;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_CREATE_BACKUP   =  0x0001;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_DOUBLE_QUOTE    =  0x0002;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_SINGLE_QUOTE    =  0x0004;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_MUST_EXIST      =  0x0008;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_COLON           =  0x0010;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_SPACE_AFTER     =  0x0020;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_HASH_COMMENT    =  0x0040;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_SECTION         =  0x0080;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_FILE_MUST_EXIST =  0x0100;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_TRIM_RESULT     =  0x0200;
replace_configuration_value_t const    REPLACE_CONFIGURATION_VALUE_RESET_TIMER     =  0x0400;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
class manager
    : public serverplugins::plugin
    , public snap::snap_child
    , public std::enable_shared_from_this<manager>
{
public:
    SERVERPLUGINS_DEFAULTS(manager);

    void                            init(bool daemon, int argc, char * argv[]);

    // serverplugins::plugin
    virtual void                    bootstrap() override;

    // new virtual
    virtual std::string             server_type() const;

    bool                            is_daemon() const;
    void                            load_plugins();
    std::vector<std::string>        get_list_of_servers();
    QString const &                 get_server_name() const;
    QString const &                 get_public_ip() const;
    std::string const &             get_signal_address() const;
    int                             get_signal_port() const;
    virtual snap::snap_string_list const &
                                    get_snapmanager_frontend() const;
    std::vector<std::string> const &
                                    get_bundle_uri() const;
    std::vector<std::string>        get_list_of_bundles() const;
    QString const &                 get_bundles_path() const;
    bundle::vector_t                load_bundles();
    QString const &                 get_data_path() const;
    QString const &                 get_cache_path() const;
    QString const &                 get_www_cache_path() const;
    QString const &                 get_reboot_required_path() const;
    virtual bool                    stop_now_prima() const;
    virtual void                    forward_message(ed::message const & message);
    bool                            upgrader();
    std::string                     lock_filename() const;
    int                             update_packages(std::string const & command);
    void                            reset_aptcheck();
    bool                            installer(QString const & bundle_name, std::string const & command, std::string const & install_values, std::set<QString> & affected_services);
    service_status_t                service_status(std::string const & service_filename, std::string const & service_name);
    void                            service_apply_status(std::string const & service_name, service_status_t const status, std::string const & wanted_by = std::string());
    void                            reboot(bool reboot = true);
    int                             package_status(std::string const & package_name, std::string & output);
    QString                         count_packages_that_can_be_updated(bool check_cache);
    std::vector<std::string>        read_filenames(std::string const & pattern) const;
    bool                            replace_configuration_value(QString const & filename, QString const & field_name, QString const & new_value, replace_configuration_value_t const flags = REPLACE_CONFIGURATION_VALUE_CREATE_BACKUP, QString const & trim_left = {});
    std::string                     get_parameter(std::string const & name) const;

    PLUGIN_SIGNAL_WITH_MODE(retrieve_status, (server_status & status), (status), NEITHER);
    PLUGIN_SIGNAL_WITH_MODE(handle_affected_services, (std::set<QString> & affected_services), (affected_services), NEITHER);
    PLUGIN_SIGNAL_WITH_MODE(communication_ready, (), (), NEITHER);
    PLUGIN_SIGNAL_WITH_MODE(process_plugin_message, (ed::message const & message, bool & processed), (message, processed), NEITHER);
    PLUGIN_SIGNAL_WITH_MODE(add_plugin_commands, (snap::snap_string_list & understood_commands), (understood_commands), NEITHER);

    static int                      get_version_major() __attribute__ ((const));
    static int                      get_version_minor() __attribute__ ((const));
    static int                      get_version_patch() __attribute__ ((const));
    static char const *             get_version_string() __attribute__ ((const));
    static std::string::size_type   search_parameter(std::string const & configuration, std::string const & parameter_name, std::string::size_type const start_pos, bool const ignore_case);
    static char const *             service_status_to_string(service_status_t const status);
    static service_status_t         string_to_service_status(std::string const & status);

protected:
    static void                     sighandler( int sig );
    int                             install_package(std::string const & package_name, std::string const & command);

    bool                            f_daemon = false;
    bool                            f_debug = false;
    advgetopt::getopt::pointer_t    f_opt = advgetopt::getopt::pointer_t();
    ed::signal_handler::pointer_t   f_signal_handler = ed::signal_handler::pointer_t();
    advgetopt::conf_file::pointer_t f_config = advgetopt::conf_file::pointer_t();
    std::string                     f_server_name = std::string();
    std::string                     f_log_conf = std::string("/etc/snapwebsites/logger/snapmanager.properties");
    std::string                     f_data_path = std::string("/var/lib/snapwebsites");
    std::string                     f_cluster_status_path = f_data_path + "/cluster-status";
    std::string                     f_bundles_path = f_data_path + "/bundles";
    std::string                     f_public_ip = std::string();
    std::string                     f_plugins_path = std::string("/usr/lib/snapwebsites/manager_plugins");
    std::string                     f_cache_path = std::string("/var/cache/snapwebsites");
    std::string                     f_www_cache_path = std::string("/var/cache/www-snapwebsites");
    std::string                     f_apt_check = std::string("/usr/lib/update-notifier/apt-check");
    std::string                     f_reboot_required = std::string("/run/reboot-required");
    std::string                     f_lock_path = std::string("/run/lock/snapwebsites");
    std::string                     f_signal_address = std::string("127.0.0.1");
    int                             f_signal_port = 4041;
    std::vector<std::string>        f_bundle_uri = std::vector<std::string>();

private:
    bool                            f_plugins_loaded = false;
};
#pragma GCC diagnostic pop


} // snap_manager namespace
// vim: ts=4 sw=4 et
